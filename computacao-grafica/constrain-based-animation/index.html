<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>TWGL Triangle Example</title>
    <script src="https://twgljs.org/dist/4.x/twgl-full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/earcut/dist/earcut.min.js"></script>

    <!-- <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style> -->
</head>

<body>
    <canvas id="canvas" width="600" height="600" style="border: 1px solid black;"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 a_position;

        uniform vec2 u_resolution;

        void main() {
            // convert the position from pixels to 0.0 to 1.0
            vec2 zeroToOne = a_position / u_resolution;
        
            // convert from 0->1 to 0->2
            vec2 zeroToTwo = zeroToOne * 2.0;
        
            // convert from 0->2 to -1->+1 (clip space)
            vec2 clipSpace = zeroToTwo - 1.0;
        
            gl_Position = vec4(clipSpace * vec2(1,-1), 0, 1);
        }
    </script>
    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;

        // uniform sampler2D u_texture;
        uniform vec4 u_color;

        void main() {
            gl_FragColor = u_color;
        }
    </script>
    <script>
        const gl = document.getElementById("canvas").getContext("webgl");
        const programInfo = twgl.createProgramInfo(gl, ["vs", "fs"]);
        const mousePosition = twgl.v3.create(0, 0, 0);

        function circleVertices(x, y, radius, numSegments) {
            const points = [];
            for (let i = 0; i <= numSegments; i++) {
                const angle = (i / numSegments) * Math.PI * 2;

                points.push(x + Math.cos(angle) * radius);
                points.push(y + Math.sin(angle) * radius);
            }
            return points;
        }

        const origin = twgl.v3.create(gl.canvas.width / 2, gl.canvas.height / 2, 0);
        const spine = {
            joints: [],
            sizes: [],
            angles: [],
        }
        for (let i = 0; i < 6; i++) {
            const position = twgl.v3.create(origin[0] - i * 50, origin[1], 0);
            spine.joints.push(position);
            spine.sizes.push(32);
            spine.angles.push(0);
        }

        const circleResolution = 32
        const maxAngle = Math.cos(Math.PI / 6); // 30 degrees
        let lastTime = 0;
        function loop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            // Physics update
            const firstLink = spine.joints[0]
            firstLink[0] = mousePosition[0];
            firstLink[1] = mousePosition[1];

            for (let i = 1; i < spine.joints.length; i++) {
                let link = spine.joints[i];

                const prevLink = spine.joints[i - 1];
                const prevLinkSize = spine.sizes[i - 1];

                const distance = twgl.v3.distance(link, prevLink);
                if (distance >= prevLinkSize) {
                    let newPos = ConstrainDistance(link, prevLink, prevLinkSize)
                    link[0] = newPos[0];
                    link[1] = newPos[1];
                }
            }

            for (let i = 2; i < spine.joints.length; i++) {
                const a = spine.joints[i - 2];
                const b = spine.joints[i - 1];
                const c = spine.joints[i];
                

                const u = twgl.v3.subtract(b, a);
                const v = twgl.v3.subtract(c, a);

                const dot = twgl.v3.dot(u, v)
                const uLengh = twgl.v3.length(u);
                const vLengh = twgl.v3.length(v);
                const angle = dot / (uLengh * vLengh);
                spine.angles[i] = angle;

                if (angle <= maxAngle) {
                    // Determine rotation direction using cross product
                    const cross = u[0] * v[1] - u[1] * v[0];
                    const sign = cross < 0 ? -1 : 1;

                    const rotationMatrix = twgl.m4.rotationZ(sign * (angle - maxAngle))
                    const relativePos = twgl.v3.subtract(c, b);
                    const rotated = twgl.m4.transformDirection(rotationMatrix, relativePos);
                    const newPos = twgl.v3.add(b, rotated);

                    // Euler Integration
                    const direction = twgl.v3.normalize(twgl.v3.subtract(newPos, c));
                    const velocity = twgl.v3.mulScalar(direction, 200 * deltaTime / 1000);
                    const tmp = twgl.v3.add(c, velocity);
                    c[0] = tmp[0];
                    c[1] = tmp[1];
                }
            }

            // Rendering
            twgl.resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.useProgram(programInfo.program);
            twgl.setUniforms(programInfo, {
                u_resolution: [gl.canvas.width, gl.canvas.height],
                u_color: [0.0, 0.0, 1.0, 1.0]
            });

            // console.log(spine.angles)
            // const polygonVertices = [];
            // // Right half of the snake
            // for (let i = 0; i < spine.joints.length; i++) {
            //     const joint = spine.joints[i];
            //     const angle = spine.angles[i];
            //     const size = spine.sizes[i];

            //     const x = joint[0] + Math.cos(angle + Math.PI / 2) * size;
            //     const y = joint[1] + Math.sin(angle + Math.PI / 2) * size;
            //     polygonVertices.push(x, y);
            // }

            // let joint = spine.joints[spine.joints.length - 1];
            // let angle = spine.angles[spine.angles.length - 1];
            // let size = spine.sizes[spine.sizes.length - 1];

            // let x = joint[0] + Math.cos(angle + Math.PI) * size;
            // let y = joint[1] + Math.sin(angle + Math.PI) * size;
            // polygonVertices.push(x, y);

            // // Left half of the snake
            // for (let i = 0; i < spine.joints.length; i++) {
            //     const joint = spine.joints[i];
            //     const angle = spine.angles[i];
            //     const size = spine.sizes[i];

            //     const x = joint[0] + Math.cos(angle - Math.PI / 2) * size;
            //     const y = joint[1] + Math.sin(angle - Math.PI / 2) * size;
            //     polygonVertices.push(x, y);
            // }

            // // Top of the head (completes the loop)
            // joint = spine.joints[0];
            // angle = spine.angles[0];
            // size = spine.sizes[0];

            // x = joint[0] + Math.cos(angle - Math.PI/6) * size;
            // y = joint[1] + Math.sin(angle - Math.PI/6) * size;
            // polygonVertices.push(x, y);

            // x = joint[0] + Math.cos(angle) * size;
            // y = joint[1] + Math.sin(angle) * size;
            // polygonVertices.push(x, y);

            // x = joint[0] + Math.cos(angle + Math.PI/6) * size;
            // y = joint[1] + Math.sin(angle + Math.PI/6) * size;
            // polygonVertices.push(x, y);

            // for (let i = 0; i < polygonVertices.length-1; i+=2) {
            //     const x = polygonVertices[i];
            //     const y = polygonVertices[i+1];

            //     let bufferInfo = twgl.createBufferInfoFromArrays(gl, {
            //         a_position: {
            //             data: circleVertices(x, y, 6, circleResolution),
            //             numComponents: 2,
            //             drawType: gl.STATIC_DRAW
            //         }
            //     })

            //     twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
            //     twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLE_FAN);
            // }

            for (let i = 0; i < spine.joints.length; i++) {
                const link = spine.joints[i];
                const size = spine.sizes[i];

                let bufferInfo = twgl.createBufferInfoFromArrays(gl, {
                    a_position: {
                        data: circleVertices(link[0], link[1], size, circleResolution),
                        numComponents: 2,
                        drawType: gl.STATIC_DRAW
                    }
                })

                twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
                twgl.drawBufferInfo(gl, bufferInfo, gl.LINE_STRIP);
            }

            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        gl.canvas.addEventListener("mousemove", (event) => {
            const rect = gl.canvas.getBoundingClientRect();
            mousePosition[0] = event.clientX - rect.left;
            mousePosition[1] = event.clientY - rect.top;
        });

        function ConstrainDistance(point, anchor, distance) {
            let result = twgl.v3.subtract(point, anchor);
            result = twgl.v3.normalize(result);
            result = twgl.v3.mulScalar(result, distance);
            return twgl.v3.add(anchor, result);
        }
    </script>
</body>

</html>