<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GJK Demo</title>
    <script src="https://twgljs.org/dist/6.x/twgl-full.min.js"></script>
</head>

<body>
    <h1>GJK (Gilbert-Johnson-Keerthi) Collision Detection and Resolve implementation</h1>
    <canvas id="canvas" width="600" height="600" style="border: 1px solid black;"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 a_position;

        uniform vec2 u_resolution;

        void main() {
            // convert the position from pixels to 0.0 to 1.0
            vec2 zeroToOne = a_position / u_resolution;
        
            // convert from 0->1 to 0->2
            vec2 zeroToTwo = zeroToOne * 2.0;
        
            // convert from 0->2 to -1->+1 (clip space)
            vec2 clipSpace = zeroToTwo - 1.0;
        
            gl_Position = vec4(clipSpace * vec2(1,-1), 0, 1);
            gl_PointSize = 5.0;
        }
    </script>
    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;

        // uniform sampler2D u_texture;
        uniform vec4 u_color;

        void main() {
            gl_FragColor = u_color;
        }
    </script>


    <script type="module">
        // import Body from "./Body.js"
        import PolygonBody from "./PolygonBody.js"
        import Particle from "./Particle.js"
        import LinearConstraint from "./LinearConstraint.js"

        const gl = document.getElementById('canvas').getContext('webgl');
        const startTime = Date.now()

        const bodies = []
        const body1 = new PolygonBody(gl, [
            [200, 100], [250, 100], [250, 150], [200, 150]
        ])
        const body2 = new PolygonBody(gl, [
            [140, 101], [210, 100], [160, 150]
        ])
        // const triangle = TriangleBuilder(100, 100)
        // const triangle2 = TriangleBuilder(140, 110)
        bodies.push(body1, body2)

        let lastTime = Date.now() - startTime
        let deltaTime = 0
        function loop(time) {
            // Physics
            deltaTime = (time - lastTime) / 1000
            lastTime = time;

            for (const body of bodies) {
                body.update(deltaTime);
            }

            // let separationPolygon
            const hit = CollisionDetection_Gjk(body1, body2)
            if (hit) {
                body1.isOverlapping = true
                let mvp = epa(body1, body2, hit)
                
                let edge1 = body1.getFarthestEdgeInDirection(twgl.v3.negate(mvp.normal))
                edge1.forEach(p => {
                    p.move(twgl.v3.add(p.position, twgl.v3.mulScalar(twgl.v3.negate(mvp.normal), mvp.depth)))
                })

                let edge2 = body2.getFarthestEdgeInDirection(mvp.normal)            
                edge2.forEach(p => {
                    p.move(twgl.v3.add(p.position, twgl.v3.mulScalar(mvp.normal, mvp.depth)))
                })
            } else {
                body1.isOverlapping = false
            }

            // Rendering
            twgl.resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // separationPolygon.draw()
            for (const body of bodies) {
                body.draw();
            }

            requestAnimationFrame(loop)
        }
        requestAnimationFrame(loop)

        function TriangleBuilder(x, y) {
            const v1 = new Particle(gl, twgl.v3.create(x, y))
            v1.gravity = twgl.v3.create(0, 0)
            const v2 = new Particle(gl, twgl.v3.create(x + 50, y))
            v2.gravity = twgl.v3.create(0, 0)
            const v3 = new Particle(gl, twgl.v3.create(x, y + 50))
            v3.gravity = twgl.v3.create(0, 0)

            const c1 = new LinearConstraint(gl, v1, v2)
            const c2 = new LinearConstraint(gl, v2, v3)
            const c3 = new LinearConstraint(gl, v3, v1)

            return new Body(gl, [v1, v2, v3], [c1, c2, c3])
        }

        function CollisionDetection_Gjk(A, B) {
            const simplex = []
            const origin = twgl.v3.create(0, 0)

            // initial search direction equals to the difference of the shapes center
            let d = twgl.v3.subtract(B.getCenter(), A.getCenter())
            d = twgl.v3.normalize(d)
            // get the first Minkowski Difference point
            simplex.push(support(A, B, d))

            // negate d for the next point
            d = twgl.v3.negate(d)

            for (let i = 0; i < 30; i++) {
                let a = support(A, B, d)
                // add a new point to the simplex because we haven't terminated yet
                simplex.push(a)

                // make sure that the last point we added actually passed the origin
                if (twgl.v3.dot(a, d) <= 0) {
                    return false
                }

                // otherwise we need to determine if the origin is in
                // the current simplex
                if (containsOrigin(simplex, d)) {
                    return simplex
                }
            }

            return false
        }

        function support(shape1, shape2, d) {
            const p1 = shape1.getFarthestPointInDirection(d);
            const p2 = shape2.getFarthestPointInDirection(twgl.v3.negate(d));

            // perform the Minkowski Difference
            const p3 = twgl.v3.subtract(p1, p2)

            // p3 is now a point in Minkowski space on the edge of the Minkowski Difference
            return p3;
        }

        function containsOrigin(simplex, d) {
            if (simplex.length == 3) {
                return triangleCase(simplex, d)
            }

            return lineCase(simplex, d)
        }

        function triangleCase(simplex, d) {
            // get the last point added to the simplex
            const [c, b, a] = simplex
            // compute AO (same thing as -A)
            const ao = twgl.v3.negate(a)

            // compute the edges
            const ab = twgl.v3.subtract(b, a)
            const ac = twgl.v3.subtract(c, a)

            // compute the normals
            const abPerp = tripleProduct(ac, ab, ab);
            const acPerp = tripleProduct(ab, ac, ac);

            // is the origin in R4 region?
            if (twgl.v3.dot(abPerp, ao) > 0) {
                // remove point c
                simplex.splice(0, 1)
                // set the new direction to abPerp
                twgl.v3.copy(abPerp, d)

                return false
            }

            // is the origin in R3?
            if (twgl.v3.dot(acPerp, ao) > 0) {
                // remove point b
                simplex.splice(1, 1)
                // set the new direction to acPerp
                twgl.v3.copy(acPerp, d)

                return false
            }

            // otherwise we know its in R5 so we can return true
            return true;
        }

        function lineCase(simplex, d) {
            // get the last point added to the simplex
            const [b, a] = simplex
            // compute AO (same thing as -A)
            const ao = twgl.v3.negate(a)
            // compute AB
            const ab = twgl.v3.subtract(b, a)
            // get the perp to AB in the direction of the origin
            const abPerp = tripleProduct(ab, ao, ab);
            // set the direction to abPerp
            twgl.v3.copy(abPerp, d)

            return false
        }

        function epa(A, B, simplex) {
            const TOLERANCE = 1e-6
            // loop to find the collision information
            while (true) {
                // obtain the feature (edge for 2D) closest to the 
                // origin on the Minkowski Difference
                const e = findClosestEdge(simplex);

                // obtain a new support point in the direction of the edge normal
                const p = support(A, B, e.normal);

                // check the distance from the origin to the edge against the
                // distance p is along e.normal
                const d = twgl.v3.dot(p, e.normal)
                if (Math.abs(d - e.distance) < TOLERANCE) {
                    // the tolerance should be something positive close to zero (ex. 0.00001)

                    // if the difference is less than the tolerance then we can
                    // assume that we cannot expand the simplex any further and
                    // we have our solution
                    return {
                        normal: e.normal,
                        depth: d
                    }
                } else {
                    // we haven't reached the edge of the Minkowski Difference
                    // so continue expanding by adding the new point to the simplex
                    // in between the points that made the closest edge
                    simplex.splice(e.index, 0, p)
                }
            }
        }

        function findClosestEdge(simplex, vertex = twgl.v3.create(0, 0)) {
            // Edge closest = new Edge();
            const closest = {
                index: 0,
                // prime the distance of the edge to the max
                distance: Number.POSITIVE_INFINITY,
                normal: twgl.v3.create(0, 0)
            }

            for (let i = 0; i < simplex.length; i++) {
                // compute the next points index
                let j = (i + 1) % simplex.length

                // get the current point and the next one
                const a = simplex[i]
                const b = simplex[j]

                // create the edge vector
                const e = twgl.v3.subtract(b, a)

                // get the vector from the origin to a
                const oa = a // or a - ORIGIN

                // get the vector from the edge towards the origin
                const n = tripleProduct(e, oa, e)
                twgl.v3.normalize(n, n)

                // calculate the distance from the origin to the edge
                const d = twgl.v3.dot(n, a)

                // check the distance against the other distances
                if (d < closest.distance) {
                    // if this edge is closer then use it
                    closest.distance = d;
                    closest.normal = n;
                    closest.index = j;
                }
            }

            // return the closest edge we found
            return closest;
        }

        function tripleProduct(a, b, c) {
            let triple1 = twgl.v3.dot(c, a)
            triple1 = twgl.v3.mulScalar(b, triple1)

            let triple2 = twgl.v3.dot(c, b)
            triple2 = twgl.v3.mulScalar(a, triple2)

            return twgl.v3.subtract(triple1, triple2)
        }

        document.addEventListener("keydown", e => {
            switch (e.key) {
                case 'd':
                    {
                        const particle = triangle.particles[0]
                        const x = particle.previousPosition[0] + 100 * deltaTime
                        particle.move(twgl.v3.create(x, particle.position[1]))
                    }

                    break;
                case 'a':
                    {
                        const particle = triangle.particles[0]
                        const x = particle.previousPosition[0] - 100 * deltaTime
                        particle.move(twgl.v3.create(x, particle.position[1]))
                    }

                    break;
                case 'w':
                    {
                        const particle = triangle.particles[0]
                        const y = particle.previousPosition[1] - 100 * deltaTime
                        particle.move(twgl.v3.create(particle.position[0], y))
                    }

                    break;
                case 's':
                    {
                        const particle = triangle.particles[0]
                        const y = particle.previousPosition[1] + 100 * deltaTime
                        particle.move(twgl.v3.create(particle.position[0], y))
                    }

                    break;
                default:
                    break;
            }
        })

        document.addEventListener("keyup", e => {
            switch (e.key) {
                case 'd':
                case 'a':
                case 'w':
                case 's':
                    // Stop all
                    for (const particle of triangle.particles) {
                        const old = twgl.v3.copy(particle.previousPosition)
                        particle.move(old) // do not change position
                    }

                default:
                    break;
            }
        })
    </script>
</body>

</html>